<root>
    <BehaviorTree ID="MainTree">
        <ReactiveSequence name="rseq">
            <ReactiveFallback name="rfall">
                <CheckObstacle name="check_obstacle" />
                <Turn name="avoid_obstacle" />
            </ReactiveFallback>
            <Forward name="move_forward" />
        </ReactiveSequence>
    </BehaviorTree>
    <Code>
        <CheckObstacle>
            import py_trees
            import sensor_msgs
            
            class CheckObstacle(py_trees.behaviour.Behaviour):
            
                def __init__(self, name: str = "CheckObstacle"):
            
                    """Configure the name of the behaviour."""
                    super().__init__(name)
                    self.logger.debug("%s.__init__()" % (self.__class__.__name__))
            
                def setup(self, **kwargs: int) -&gt; None:
            
                    # Get the node passed from the tree
                    try:
                        self.node = kwargs['node']
                    except KeyError as e:
                        error_message = "didn't find 'node' in setup's kwargs [{}][{}]".format(self.qualified_name)
                        raise KeyError(error_message) from e  # 'direct cause' traceability
            
                    self.subscription = self.node.create_subscription(
                        sensor_msgs.msg.LaserScan,
                        '/scan',
                        self.listener_callback,
                        10)
                
                    self.scan = sensor_msgs.msg.LaserScan()
            
                    # Register blackboard topics
                    self.blackboard = py_trees.blackboard.Client(name="Global")
                    self.blackboard.register_key(key="foo", access=py_trees.common.Access.WRITE)
            
                def initialise(self) -&gt; None:
            
                    """Reset a counter variable."""
                    self.logger.debug("%s.initialise()" % (self.__class__.__name__))
            
                def listener_callback(self, msg):
                    self.scan = msg
            
                def update(self) -&gt; py_trees.common.Status:
            
                    if len(self.scan.ranges) == 0: new_status = py_trees.common.Status.INVALID
                    elif self.scan.ranges[0] &gt; 1: new_status = py_trees.common.Status.SUCCESS
                    else: new_status = py_trees.common.Status.FAILURE
            
                    self.blackboard.foo = "bar"
            
                    return new_status
            
                def terminate(self, new_status: py_trees.common.Status) -&gt; None:
            
                    """Nothing to clean up in this example."""
            
                    self.logger.debug(
            
                        "%s.terminate()[%s-&gt;%s]"
            
                        % (self.__class__.__name__, self.status, new_status)
            
                    )
            
        </CheckObstacle>
        <Turn>
            import py_trees
            import geometry_msgs
            import py_trees_ros
            
            class Turn(py_trees.behaviour.Behaviour):
            
                def __init__(self, name: str = "Turn"):
            
                    """Configure the name of the behaviour."""
                    super().__init__(name)
                    self.logger.debug("%s.__init__()" % (self.__class__.__name__))
            
                def setup(self, **kwargs: int) -&gt; None:
            
                    # Get the node passed from the tree
                    try:
                        self.node = kwargs['node']
                    except KeyError as e:
                        error_message = "didn't find 'node' in setup's kwargs [{}][{}]".format(self.qualified_name)
                        raise KeyError(error_message) from e  # 'direct cause' traceability
            
                    self.logger.debug("%s.setup()" % (self.__class__.__name__))
            
                    self.publisher = self.node.create_publisher(
                        msg_type=geometry_msgs.msg.Twist,
                        topic="/cmd_vel",
                        qos_profile=10
                    )
            
                def initialise(self) -&gt; None:
            
                    """Reset a counter variable."""
            
                    self.logger.debug("%s.initialise()" % (self.__class__.__name__))
                    self.counter = 0
            
                def update(self) -&gt; py_trees.common.Status:
            
                    msg = geometry_msgs.msg.Twist()
                    msg.angular.z = 0.4
                    self.publisher.publish(msg)
            
                    return py_trees.common.Status.RUNNING 
            
                def terminate(self, new_status: py_trees.common.Status) -&gt; None:
            
                    """Nothing to clean up in this example."""
            
                    self.logger.debug(
            
                        "%s.terminate()[%s-&gt;%s]"
            
                        % (self.__class__.__name__, self.status, new_status)
            
                    )
            
        </Turn>
        <Forward>
            import py_trees
            import geometry_msgs
            import py_trees_ros
            
            class Forward(py_trees.behaviour.Behaviour):
            
                def __init__(self, name: str = "Move"):
            
                    """Configure the name of the behaviour."""
                    super().__init__(name)
                    self.logger.debug("%s.__init__()" % (self.__class__.__name__))
            
                def setup(self, **kwargs) -&gt; None:
            
                    # Get the node passed from the tree
                    try:
                        self.node = kwargs['node']
                    except KeyError as e:
                        error_message = "didn't find 'node' in setup's kwargs [{}][{}]".format(self.qualified_name)
                        raise KeyError(error_message) from e  # 'direct cause' traceability
            
                    self.publisher = self.node.create_publisher(
                        msg_type=geometry_msgs.msg.Twist,
                        topic="/cmd_vel",
                        qos_profile=10
                    )
            
                    # Register blackboard topics
                    self.blackboard = py_trees.blackboard.Client(name="Global")
                    self.blackboard.register_key(key="foo", access=py_trees.common.Access.WRITE)
            
            
                def initialise(self) -&gt; None:
            
                    """Reset a counter variable."""
                    self.logger.debug("%s.initialise()" % (self.__class__.__name__))
                    self.counter = 0
            
                def update(self) -&gt; py_trees.common.Status:
            
                    self.blackboard.foo = "foo"
            
                    msg = geometry_msgs.msg.Twist()
                    msg.linear.x = 0.4
                    self.publisher.publish(msg)
            
                    return py_trees.common.Status.RUNNING 
            
                def terminate(self, new_status: py_trees.common.Status) -&gt; None:
            
                    """Nothing to clean up in this example."""
            
                    self.logger.debug(
            
                        "%s.terminate()[%s-&gt;%s]"
            
                        % (self.__class__.__name__, self.status, new_status)
            
                    )
        </Forward>
    </Code>
</root>